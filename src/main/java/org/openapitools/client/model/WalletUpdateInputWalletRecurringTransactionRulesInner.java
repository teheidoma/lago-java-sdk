/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.28.1
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.WalletRecurringTransactionRuleTransactionMetadataInner;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Object that represents rule for wallet recurring transactions.
 */
@JsonPropertyOrder({
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_LAGO_ID,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_TRIGGER,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_METHOD,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_INTERVAL,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_THRESHOLD_CREDITS,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_PAID_CREDITS,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_GRANTED_CREDITS,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_STARTED_AT,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_EXPIRATION_AT,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_TARGET_ONGOING_BALANCE,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT,
  WalletUpdateInputWalletRecurringTransactionRulesInner.JSON_PROPERTY_TRANSACTION_METADATA
})
@JsonTypeName("WalletUpdateInput_wallet_recurring_transaction_rules_inner")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-23T15:05:45.180675+03:00[Europe/Kiev]", comments = "Generator version: 7.13.0")
public class WalletUpdateInputWalletRecurringTransactionRulesInner {
  public static final String JSON_PROPERTY_LAGO_ID = "lago_id";
  @javax.annotation.Nullable
  private UUID lagoId;

  /**
   * The trigger. Possible values are &#x60;interval&#x60; or &#x60;threshold&#x60;.
   */
  public enum TriggerEnum {
    INTERVAL(String.valueOf("interval")),
    
    THRESHOLD(String.valueOf("threshold"));

    private String value;

    TriggerEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TriggerEnum fromValue(String value) {
      for (TriggerEnum b : TriggerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_TRIGGER = "trigger";
  @javax.annotation.Nullable
  private TriggerEnum trigger;

  /**
   * The method used for recurring top-up. Possible values are &#x60;fixed&#x60; or &#x60;target&#x60;.
   */
  public enum MethodEnum {
    FIXED(String.valueOf("fixed")),
    
    TARGET(String.valueOf("target"));

    private String value;

    MethodEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static MethodEnum fromValue(String value) {
      for (MethodEnum b : MethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_METHOD = "method";
  @javax.annotation.Nullable
  private MethodEnum method;

  /**
   * The interval used for recurring top-up. It represents the frequency at which automatic top-up occurs. The interval can be one of the following values: &#x60;weekly&#x60;, &#x60;monthly&#x60;, &#x60;quarterly&#x60; or &#x60;yearly&#x60;. Required only when trigger is set to &#x60;interval&#x60;.
   */
  public enum IntervalEnum {
    WEEKLY(String.valueOf("weekly")),
    
    MONTHLY(String.valueOf("monthly")),
    
    QUARTERLY(String.valueOf("quarterly")),
    
    YEARLY(String.valueOf("yearly"));

    private String value;

    IntervalEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static IntervalEnum fromValue(String value) {
      for (IntervalEnum b : IntervalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_INTERVAL = "interval";
  @javax.annotation.Nullable
  private IntervalEnum interval;

  public static final String JSON_PROPERTY_THRESHOLD_CREDITS = "threshold_credits";
  @javax.annotation.Nullable
  private String thresholdCredits;

  public static final String JSON_PROPERTY_PAID_CREDITS = "paid_credits";
  @javax.annotation.Nullable
  private String paidCredits;

  public static final String JSON_PROPERTY_GRANTED_CREDITS = "granted_credits";
  @javax.annotation.Nullable
  private String grantedCredits;

  public static final String JSON_PROPERTY_STARTED_AT = "started_at";
  @javax.annotation.Nullable
  private OffsetDateTime startedAt;

  public static final String JSON_PROPERTY_EXPIRATION_AT = "expiration_at";
  private JsonNullable<OffsetDateTime> expirationAt = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_TARGET_ONGOING_BALANCE = "target_ongoing_balance";
  @javax.annotation.Nullable
  private String targetOngoingBalance;

  public static final String JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT = "invoice_requires_successful_payment";
  @javax.annotation.Nullable
  private Boolean invoiceRequiresSuccessfulPayment;

  public static final String JSON_PROPERTY_TRANSACTION_METADATA = "transaction_metadata";
  @javax.annotation.Nullable
  private List<WalletRecurringTransactionRuleTransactionMetadataInner> transactionMetadata = new ArrayList<>();

  public WalletUpdateInputWalletRecurringTransactionRulesInner() {
  }

  public WalletUpdateInputWalletRecurringTransactionRulesInner lagoId(@javax.annotation.Nullable UUID lagoId) {
    
    this.lagoId = lagoId;
    return this;
  }

  /**
   * A unique identifier for the recurring transaction rule in the Lago application. Can be used to update a recurring transaction rule.
   * @return lagoId
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public UUID getLagoId() {
    return lagoId;
  }


  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLagoId(@javax.annotation.Nullable UUID lagoId) {
    this.lagoId = lagoId;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner trigger(@javax.annotation.Nullable TriggerEnum trigger) {
    
    this.trigger = trigger;
    return this;
  }

  /**
   * The trigger. Possible values are &#x60;interval&#x60; or &#x60;threshold&#x60;.
   * @return trigger
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TRIGGER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TriggerEnum getTrigger() {
    return trigger;
  }


  @JsonProperty(JSON_PROPERTY_TRIGGER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTrigger(@javax.annotation.Nullable TriggerEnum trigger) {
    this.trigger = trigger;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner method(@javax.annotation.Nullable MethodEnum method) {
    
    this.method = method;
    return this;
  }

  /**
   * The method used for recurring top-up. Possible values are &#x60;fixed&#x60; or &#x60;target&#x60;.
   * @return method
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public MethodEnum getMethod() {
    return method;
  }


  @JsonProperty(JSON_PROPERTY_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMethod(@javax.annotation.Nullable MethodEnum method) {
    this.method = method;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner interval(@javax.annotation.Nullable IntervalEnum interval) {
    
    this.interval = interval;
    return this;
  }

  /**
   * The interval used for recurring top-up. It represents the frequency at which automatic top-up occurs. The interval can be one of the following values: &#x60;weekly&#x60;, &#x60;monthly&#x60;, &#x60;quarterly&#x60; or &#x60;yearly&#x60;. Required only when trigger is set to &#x60;interval&#x60;.
   * @return interval
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public IntervalEnum getInterval() {
    return interval;
  }


  @JsonProperty(JSON_PROPERTY_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInterval(@javax.annotation.Nullable IntervalEnum interval) {
    this.interval = interval;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner thresholdCredits(@javax.annotation.Nullable String thresholdCredits) {
    
    this.thresholdCredits = thresholdCredits;
    return this;
  }

  /**
   * The threshold for recurring top-ups is the value at which an automatic top-up is triggered. For example, if this threshold is set at 10 credits, an automatic top-up will occur whenever the wallet balance falls to or below 10 credits. Required only when trigger is set to &#x60;threshold&#x60;.
   * @return thresholdCredits
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_THRESHOLD_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getThresholdCredits() {
    return thresholdCredits;
  }


  @JsonProperty(JSON_PROPERTY_THRESHOLD_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setThresholdCredits(@javax.annotation.Nullable String thresholdCredits) {
    this.thresholdCredits = thresholdCredits;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner paidCredits(@javax.annotation.Nullable String paidCredits) {
    
    this.paidCredits = paidCredits;
    return this;
  }

  /**
   * The number of paid credits. Required only if there is no granted credits.
   * @return paidCredits
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PAID_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getPaidCredits() {
    return paidCredits;
  }


  @JsonProperty(JSON_PROPERTY_PAID_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPaidCredits(@javax.annotation.Nullable String paidCredits) {
    this.paidCredits = paidCredits;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner grantedCredits(@javax.annotation.Nullable String grantedCredits) {
    
    this.grantedCredits = grantedCredits;
    return this;
  }

  /**
   * The number of free granted credits. Required only if there is no paid credits.
   * @return grantedCredits
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_GRANTED_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getGrantedCredits() {
    return grantedCredits;
  }


  @JsonProperty(JSON_PROPERTY_GRANTED_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setGrantedCredits(@javax.annotation.Nullable String grantedCredits) {
    this.grantedCredits = grantedCredits;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner startedAt(@javax.annotation.Nullable OffsetDateTime startedAt) {
    
    this.startedAt = startedAt;
    return this;
  }

  /**
   * The effective start date for recurring top-ups. This date should be provided in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).
   * @return startedAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STARTED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getStartedAt() {
    return startedAt;
  }


  @JsonProperty(JSON_PROPERTY_STARTED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartedAt(@javax.annotation.Nullable OffsetDateTime startedAt) {
    this.startedAt = startedAt;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner expirationAt(@javax.annotation.Nullable OffsetDateTime expirationAt) {
    this.expirationAt = JsonNullable.<OffsetDateTime>of(expirationAt);
    
    return this;
  }

  /**
   * The expiration date and time for this specific recurring transaction rule. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return expirationAt
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public OffsetDateTime getExpirationAt() {
        return expirationAt.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_EXPIRATION_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getExpirationAt_JsonNullable() {
    return expirationAt;
  }
  
  @JsonProperty(JSON_PROPERTY_EXPIRATION_AT)
  public void setExpirationAt_JsonNullable(JsonNullable<OffsetDateTime> expirationAt) {
    this.expirationAt = expirationAt;
  }

  public void setExpirationAt(@javax.annotation.Nullable OffsetDateTime expirationAt) {
    this.expirationAt = JsonNullable.<OffsetDateTime>of(expirationAt);
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner targetOngoingBalance(@javax.annotation.Nullable String targetOngoingBalance) {
    
    this.targetOngoingBalance = targetOngoingBalance;
    return this;
  }

  /**
   * The target ongoing balance is the value set for the ongoing balance to be reached by the automatic top-up. Required only when trigger is set to &#x60;target&#x60;.
   * @return targetOngoingBalance
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TARGET_ONGOING_BALANCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getTargetOngoingBalance() {
    return targetOngoingBalance;
  }


  @JsonProperty(JSON_PROPERTY_TARGET_ONGOING_BALANCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTargetOngoingBalance(@javax.annotation.Nullable String targetOngoingBalance) {
    this.targetOngoingBalance = targetOngoingBalance;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner invoiceRequiresSuccessfulPayment(@javax.annotation.Nullable Boolean invoiceRequiresSuccessfulPayment) {
    
    this.invoiceRequiresSuccessfulPayment = invoiceRequiresSuccessfulPayment;
    return this;
  }

  /**
   * A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.
   * @return invoiceRequiresSuccessfulPayment
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getInvoiceRequiresSuccessfulPayment() {
    return invoiceRequiresSuccessfulPayment;
  }


  @JsonProperty(JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInvoiceRequiresSuccessfulPayment(@javax.annotation.Nullable Boolean invoiceRequiresSuccessfulPayment) {
    this.invoiceRequiresSuccessfulPayment = invoiceRequiresSuccessfulPayment;
  }


  public WalletUpdateInputWalletRecurringTransactionRulesInner transactionMetadata(@javax.annotation.Nullable List<WalletRecurringTransactionRuleTransactionMetadataInner> transactionMetadata) {
    
    this.transactionMetadata = transactionMetadata;
    return this;
  }

  public WalletUpdateInputWalletRecurringTransactionRulesInner addTransactionMetadataItem(WalletRecurringTransactionRuleTransactionMetadataInner transactionMetadataItem) {
    if (this.transactionMetadata == null) {
      this.transactionMetadata = new ArrayList<>();
    }
    this.transactionMetadata.add(transactionMetadataItem);
    return this;
  }

  /**
   * This optional field allows you to store a list of key-value pairs containing additional information or custom attributes. These key-value pairs will populate the metadata of the wallet transactions triggered by this rule.
   * @return transactionMetadata
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TRANSACTION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<WalletRecurringTransactionRuleTransactionMetadataInner> getTransactionMetadata() {
    return transactionMetadata;
  }


  @JsonProperty(JSON_PROPERTY_TRANSACTION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTransactionMetadata(@javax.annotation.Nullable List<WalletRecurringTransactionRuleTransactionMetadataInner> transactionMetadata) {
    this.transactionMetadata = transactionMetadata;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WalletUpdateInputWalletRecurringTransactionRulesInner walletUpdateInputWalletRecurringTransactionRulesInner = (WalletUpdateInputWalletRecurringTransactionRulesInner) o;
    return Objects.equals(this.lagoId, walletUpdateInputWalletRecurringTransactionRulesInner.lagoId) &&
        Objects.equals(this.trigger, walletUpdateInputWalletRecurringTransactionRulesInner.trigger) &&
        Objects.equals(this.method, walletUpdateInputWalletRecurringTransactionRulesInner.method) &&
        Objects.equals(this.interval, walletUpdateInputWalletRecurringTransactionRulesInner.interval) &&
        Objects.equals(this.thresholdCredits, walletUpdateInputWalletRecurringTransactionRulesInner.thresholdCredits) &&
        Objects.equals(this.paidCredits, walletUpdateInputWalletRecurringTransactionRulesInner.paidCredits) &&
        Objects.equals(this.grantedCredits, walletUpdateInputWalletRecurringTransactionRulesInner.grantedCredits) &&
        Objects.equals(this.startedAt, walletUpdateInputWalletRecurringTransactionRulesInner.startedAt) &&
        equalsNullable(this.expirationAt, walletUpdateInputWalletRecurringTransactionRulesInner.expirationAt) &&
        Objects.equals(this.targetOngoingBalance, walletUpdateInputWalletRecurringTransactionRulesInner.targetOngoingBalance) &&
        Objects.equals(this.invoiceRequiresSuccessfulPayment, walletUpdateInputWalletRecurringTransactionRulesInner.invoiceRequiresSuccessfulPayment) &&
        Objects.equals(this.transactionMetadata, walletUpdateInputWalletRecurringTransactionRulesInner.transactionMetadata);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(lagoId, trigger, method, interval, thresholdCredits, paidCredits, grantedCredits, startedAt, hashCodeNullable(expirationAt), targetOngoingBalance, invoiceRequiresSuccessfulPayment, transactionMetadata);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WalletUpdateInputWalletRecurringTransactionRulesInner {\n");
    sb.append("    lagoId: ").append(toIndentedString(lagoId)).append("\n");
    sb.append("    trigger: ").append(toIndentedString(trigger)).append("\n");
    sb.append("    method: ").append(toIndentedString(method)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    thresholdCredits: ").append(toIndentedString(thresholdCredits)).append("\n");
    sb.append("    paidCredits: ").append(toIndentedString(paidCredits)).append("\n");
    sb.append("    grantedCredits: ").append(toIndentedString(grantedCredits)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("    expirationAt: ").append(toIndentedString(expirationAt)).append("\n");
    sb.append("    targetOngoingBalance: ").append(toIndentedString(targetOngoingBalance)).append("\n");
    sb.append("    invoiceRequiresSuccessfulPayment: ").append(toIndentedString(invoiceRequiresSuccessfulPayment)).append("\n");
    sb.append("    transactionMetadata: ").append(toIndentedString(transactionMetadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

