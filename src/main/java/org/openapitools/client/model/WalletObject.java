/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.28.1
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.Currency;
import org.openapitools.client.model.WalletRecurringTransactionRule;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * WalletObject
 */
@JsonPropertyOrder({
  WalletObject.JSON_PROPERTY_LAGO_ID,
  WalletObject.JSON_PROPERTY_LAGO_CUSTOMER_ID,
  WalletObject.JSON_PROPERTY_EXTERNAL_CUSTOMER_ID,
  WalletObject.JSON_PROPERTY_STATUS,
  WalletObject.JSON_PROPERTY_CURRENCY,
  WalletObject.JSON_PROPERTY_NAME,
  WalletObject.JSON_PROPERTY_RATE_AMOUNT,
  WalletObject.JSON_PROPERTY_CREDITS_BALANCE,
  WalletObject.JSON_PROPERTY_BALANCE_CENTS,
  WalletObject.JSON_PROPERTY_CONSUMED_CREDITS,
  WalletObject.JSON_PROPERTY_CREATED_AT,
  WalletObject.JSON_PROPERTY_EXPIRATION_AT,
  WalletObject.JSON_PROPERTY_LAST_BALANCE_SYNC_AT,
  WalletObject.JSON_PROPERTY_LAST_CONSUMED_CREDIT_AT,
  WalletObject.JSON_PROPERTY_TERMINATED_AT,
  WalletObject.JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT,
  WalletObject.JSON_PROPERTY_RECURRING_TRANSACTION_RULES,
  WalletObject.JSON_PROPERTY_ONGOING_BALANCE_CENTS,
  WalletObject.JSON_PROPERTY_ONGOING_USAGE_BALANCE_CENTS,
  WalletObject.JSON_PROPERTY_CREDITS_ONGOING_BALANCE,
  WalletObject.JSON_PROPERTY_CREDITS_ONGOING_USAGE_BALANCE
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-23T15:05:45.180675+03:00[Europe/Kiev]", comments = "Generator version: 7.13.0")
public class WalletObject {
  public static final String JSON_PROPERTY_LAGO_ID = "lago_id";
  @javax.annotation.Nonnull
  private UUID lagoId;

  public static final String JSON_PROPERTY_LAGO_CUSTOMER_ID = "lago_customer_id";
  @javax.annotation.Nonnull
  private UUID lagoCustomerId;

  public static final String JSON_PROPERTY_EXTERNAL_CUSTOMER_ID = "external_customer_id";
  @javax.annotation.Nonnull
  private String externalCustomerId;

  /**
   * The status of the wallet. Possible values are &#x60;active&#x60; or &#x60;terminated&#x60;.
   */
  public enum StatusEnum {
    ACTIVE(String.valueOf("active")),
    
    TERMINATED(String.valueOf("terminated"));

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_STATUS = "status";
  @javax.annotation.Nonnull
  private StatusEnum status;

  public static final String JSON_PROPERTY_CURRENCY = "currency";
  @javax.annotation.Nonnull
  private Currency currency;

  public static final String JSON_PROPERTY_NAME = "name";
  @javax.annotation.Nullable
  private String name;

  public static final String JSON_PROPERTY_RATE_AMOUNT = "rate_amount";
  @javax.annotation.Nonnull
  private String rateAmount;

  public static final String JSON_PROPERTY_CREDITS_BALANCE = "credits_balance";
  @javax.annotation.Nonnull
  private String creditsBalance;

  public static final String JSON_PROPERTY_BALANCE_CENTS = "balance_cents";
  @javax.annotation.Nonnull
  private Integer balanceCents;

  public static final String JSON_PROPERTY_CONSUMED_CREDITS = "consumed_credits";
  @javax.annotation.Nonnull
  private String consumedCredits;

  public static final String JSON_PROPERTY_CREATED_AT = "created_at";
  @javax.annotation.Nonnull
  private OffsetDateTime createdAt;

  public static final String JSON_PROPERTY_EXPIRATION_AT = "expiration_at";
  private JsonNullable<OffsetDateTime> expirationAt = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_LAST_BALANCE_SYNC_AT = "last_balance_sync_at";
  private JsonNullable<OffsetDateTime> lastBalanceSyncAt = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_LAST_CONSUMED_CREDIT_AT = "last_consumed_credit_at";
  private JsonNullable<OffsetDateTime> lastConsumedCreditAt = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_TERMINATED_AT = "terminated_at";
  private JsonNullable<OffsetDateTime> terminatedAt = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT = "invoice_requires_successful_payment";
  @javax.annotation.Nullable
  private Boolean invoiceRequiresSuccessfulPayment;

  public static final String JSON_PROPERTY_RECURRING_TRANSACTION_RULES = "recurring_transaction_rules";
  @javax.annotation.Nullable
  private List<WalletRecurringTransactionRule> recurringTransactionRules = new ArrayList<>();

  public static final String JSON_PROPERTY_ONGOING_BALANCE_CENTS = "ongoing_balance_cents";
  @javax.annotation.Nonnull
  private Integer ongoingBalanceCents;

  public static final String JSON_PROPERTY_ONGOING_USAGE_BALANCE_CENTS = "ongoing_usage_balance_cents";
  @javax.annotation.Nonnull
  private Integer ongoingUsageBalanceCents;

  public static final String JSON_PROPERTY_CREDITS_ONGOING_BALANCE = "credits_ongoing_balance";
  @javax.annotation.Nonnull
  private String creditsOngoingBalance;

  public static final String JSON_PROPERTY_CREDITS_ONGOING_USAGE_BALANCE = "credits_ongoing_usage_balance";
  @javax.annotation.Nonnull
  private String creditsOngoingUsageBalance;

  public WalletObject() {
  }

  public WalletObject lagoId(@javax.annotation.Nonnull UUID lagoId) {
    
    this.lagoId = lagoId;
    return this;
  }

  /**
   * Unique identifier assigned to the wallet within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the wallet&#39;s record within the Lago system.
   * @return lagoId
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getLagoId() {
    return lagoId;
  }


  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLagoId(@javax.annotation.Nonnull UUID lagoId) {
    this.lagoId = lagoId;
  }


  public WalletObject lagoCustomerId(@javax.annotation.Nonnull UUID lagoCustomerId) {
    
    this.lagoCustomerId = lagoCustomerId;
    return this;
  }

  /**
   * Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer&#39;s record within the Lago system.
   * @return lagoCustomerId
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LAGO_CUSTOMER_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getLagoCustomerId() {
    return lagoCustomerId;
  }


  @JsonProperty(JSON_PROPERTY_LAGO_CUSTOMER_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLagoCustomerId(@javax.annotation.Nonnull UUID lagoCustomerId) {
    this.lagoCustomerId = lagoCustomerId;
  }


  public WalletObject externalCustomerId(@javax.annotation.Nonnull String externalCustomerId) {
    
    this.externalCustomerId = externalCustomerId;
    return this;
  }

  /**
   * The customer external unique identifier (provided by your own application)
   * @return externalCustomerId
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_EXTERNAL_CUSTOMER_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getExternalCustomerId() {
    return externalCustomerId;
  }


  @JsonProperty(JSON_PROPERTY_EXTERNAL_CUSTOMER_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setExternalCustomerId(@javax.annotation.Nonnull String externalCustomerId) {
    this.externalCustomerId = externalCustomerId;
  }


  public WalletObject status(@javax.annotation.Nonnull StatusEnum status) {
    
    this.status = status;
    return this;
  }

  /**
   * The status of the wallet. Possible values are &#x60;active&#x60; or &#x60;terminated&#x60;.
   * @return status
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_STATUS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public StatusEnum getStatus() {
    return status;
  }


  @JsonProperty(JSON_PROPERTY_STATUS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setStatus(@javax.annotation.Nonnull StatusEnum status) {
    this.status = status;
  }


  public WalletObject currency(@javax.annotation.Nonnull Currency currency) {
    
    this.currency = currency;
    return this;
  }

  /**
   * The currency of the wallet.
   * @return currency
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CURRENCY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Currency getCurrency() {
    return currency;
  }


  @JsonProperty(JSON_PROPERTY_CURRENCY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCurrency(@javax.annotation.Nonnull Currency currency) {
    this.currency = currency;
  }


  public WalletObject name(@javax.annotation.Nullable String name) {
    
    this.name = name;
    return this;
  }

  /**
   * The name of the wallet.
   * @return name
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public WalletObject rateAmount(@javax.annotation.Nonnull String rateAmount) {
    
    this.rateAmount = rateAmount;
    return this;
  }

  /**
   * The rate of conversion between credits and the amount in the specified currency. It indicates the ratio or factor used to convert credits into the corresponding monetary value in the currency of the transaction.
   * @return rateAmount
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RATE_AMOUNT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getRateAmount() {
    return rateAmount;
  }


  @JsonProperty(JSON_PROPERTY_RATE_AMOUNT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRateAmount(@javax.annotation.Nonnull String rateAmount) {
    this.rateAmount = rateAmount;
  }


  public WalletObject creditsBalance(@javax.annotation.Nonnull String creditsBalance) {
    
    this.creditsBalance = creditsBalance;
    return this;
  }

  /**
   * The current wallet balance expressed in credits. This reflects the available balance after all transactions are settled.
   * @return creditsBalance
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREDITS_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getCreditsBalance() {
    return creditsBalance;
  }


  @JsonProperty(JSON_PROPERTY_CREDITS_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreditsBalance(@javax.annotation.Nonnull String creditsBalance) {
    this.creditsBalance = creditsBalance;
  }


  public WalletObject balanceCents(@javax.annotation.Nonnull Integer balanceCents) {
    
    this.balanceCents = balanceCents;
    return this;
  }

  /**
   * The current wallet balance expressed in cents. This reflects the available balance after all transactions are settled.
   * @return balanceCents
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_BALANCE_CENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Integer getBalanceCents() {
    return balanceCents;
  }


  @JsonProperty(JSON_PROPERTY_BALANCE_CENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setBalanceCents(@javax.annotation.Nonnull Integer balanceCents) {
    this.balanceCents = balanceCents;
  }


  public WalletObject consumedCredits(@javax.annotation.Nonnull String consumedCredits) {
    
    this.consumedCredits = consumedCredits;
    return this;
  }

  /**
   * The number of consumed credits.
   * @return consumedCredits
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CONSUMED_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getConsumedCredits() {
    return consumedCredits;
  }


  @JsonProperty(JSON_PROPERTY_CONSUMED_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setConsumedCredits(@javax.annotation.Nonnull String consumedCredits) {
    this.consumedCredits = consumedCredits;
  }


  public WalletObject createdAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    
    this.createdAt = createdAt;
    return this;
  }

  /**
   * The date of the wallet creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).
   * @return createdAt
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }


  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreatedAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public WalletObject expirationAt(@javax.annotation.Nullable OffsetDateTime expirationAt) {
    this.expirationAt = JsonNullable.<OffsetDateTime>of(expirationAt);
    
    return this;
  }

  /**
   * The date and time that determines when the wallet will expire. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return expirationAt
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public OffsetDateTime getExpirationAt() {
        return expirationAt.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_EXPIRATION_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getExpirationAt_JsonNullable() {
    return expirationAt;
  }
  
  @JsonProperty(JSON_PROPERTY_EXPIRATION_AT)
  public void setExpirationAt_JsonNullable(JsonNullable<OffsetDateTime> expirationAt) {
    this.expirationAt = expirationAt;
  }

  public void setExpirationAt(@javax.annotation.Nullable OffsetDateTime expirationAt) {
    this.expirationAt = JsonNullable.<OffsetDateTime>of(expirationAt);
  }


  public WalletObject lastBalanceSyncAt(@javax.annotation.Nullable OffsetDateTime lastBalanceSyncAt) {
    this.lastBalanceSyncAt = JsonNullable.<OffsetDateTime>of(lastBalanceSyncAt);
    
    return this;
  }

  /**
   * The date and time of the last balance top-up. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return lastBalanceSyncAt
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public OffsetDateTime getLastBalanceSyncAt() {
        return lastBalanceSyncAt.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_LAST_BALANCE_SYNC_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getLastBalanceSyncAt_JsonNullable() {
    return lastBalanceSyncAt;
  }
  
  @JsonProperty(JSON_PROPERTY_LAST_BALANCE_SYNC_AT)
  public void setLastBalanceSyncAt_JsonNullable(JsonNullable<OffsetDateTime> lastBalanceSyncAt) {
    this.lastBalanceSyncAt = lastBalanceSyncAt;
  }

  public void setLastBalanceSyncAt(@javax.annotation.Nullable OffsetDateTime lastBalanceSyncAt) {
    this.lastBalanceSyncAt = JsonNullable.<OffsetDateTime>of(lastBalanceSyncAt);
  }


  public WalletObject lastConsumedCreditAt(@javax.annotation.Nullable OffsetDateTime lastConsumedCreditAt) {
    this.lastConsumedCreditAt = JsonNullable.<OffsetDateTime>of(lastConsumedCreditAt);
    
    return this;
  }

  /**
   * The date and time of the last credits consumption. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return lastConsumedCreditAt
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public OffsetDateTime getLastConsumedCreditAt() {
        return lastConsumedCreditAt.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_LAST_CONSUMED_CREDIT_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getLastConsumedCreditAt_JsonNullable() {
    return lastConsumedCreditAt;
  }
  
  @JsonProperty(JSON_PROPERTY_LAST_CONSUMED_CREDIT_AT)
  public void setLastConsumedCreditAt_JsonNullable(JsonNullable<OffsetDateTime> lastConsumedCreditAt) {
    this.lastConsumedCreditAt = lastConsumedCreditAt;
  }

  public void setLastConsumedCreditAt(@javax.annotation.Nullable OffsetDateTime lastConsumedCreditAt) {
    this.lastConsumedCreditAt = JsonNullable.<OffsetDateTime>of(lastConsumedCreditAt);
  }


  public WalletObject terminatedAt(@javax.annotation.Nullable OffsetDateTime terminatedAt) {
    this.terminatedAt = JsonNullable.<OffsetDateTime>of(terminatedAt);
    
    return this;
  }

  /**
   * The date of terminaison of the wallet. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return terminatedAt
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public OffsetDateTime getTerminatedAt() {
        return terminatedAt.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TERMINATED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getTerminatedAt_JsonNullable() {
    return terminatedAt;
  }
  
  @JsonProperty(JSON_PROPERTY_TERMINATED_AT)
  public void setTerminatedAt_JsonNullable(JsonNullable<OffsetDateTime> terminatedAt) {
    this.terminatedAt = terminatedAt;
  }

  public void setTerminatedAt(@javax.annotation.Nullable OffsetDateTime terminatedAt) {
    this.terminatedAt = JsonNullable.<OffsetDateTime>of(terminatedAt);
  }


  public WalletObject invoiceRequiresSuccessfulPayment(@javax.annotation.Nullable Boolean invoiceRequiresSuccessfulPayment) {
    
    this.invoiceRequiresSuccessfulPayment = invoiceRequiresSuccessfulPayment;
    return this;
  }

  /**
   * A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.
   * @return invoiceRequiresSuccessfulPayment
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getInvoiceRequiresSuccessfulPayment() {
    return invoiceRequiresSuccessfulPayment;
  }


  @JsonProperty(JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInvoiceRequiresSuccessfulPayment(@javax.annotation.Nullable Boolean invoiceRequiresSuccessfulPayment) {
    this.invoiceRequiresSuccessfulPayment = invoiceRequiresSuccessfulPayment;
  }


  public WalletObject recurringTransactionRules(@javax.annotation.Nullable List<WalletRecurringTransactionRule> recurringTransactionRules) {
    
    this.recurringTransactionRules = recurringTransactionRules;
    return this;
  }

  public WalletObject addRecurringTransactionRulesItem(WalletRecurringTransactionRule recurringTransactionRulesItem) {
    if (this.recurringTransactionRules == null) {
      this.recurringTransactionRules = new ArrayList<>();
    }
    this.recurringTransactionRules.add(recurringTransactionRulesItem);
    return this;
  }

  /**
   * List of recurring transaction rules. Currently, we only allow one recurring rule per wallet.
   * @return recurringTransactionRules
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RECURRING_TRANSACTION_RULES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<WalletRecurringTransactionRule> getRecurringTransactionRules() {
    return recurringTransactionRules;
  }


  @JsonProperty(JSON_PROPERTY_RECURRING_TRANSACTION_RULES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecurringTransactionRules(@javax.annotation.Nullable List<WalletRecurringTransactionRule> recurringTransactionRules) {
    this.recurringTransactionRules = recurringTransactionRules;
  }


  public WalletObject ongoingBalanceCents(@javax.annotation.Nonnull Integer ongoingBalanceCents) {
    
    this.ongoingBalanceCents = ongoingBalanceCents;
    return this;
  }

  /**
   * The ongoing wallet balance expressed in cents. This represents the &#x60;balance_cents&#x60; minus the &#x60;ongoing_usage_balance_cents&#x60;, showing the real time balance after accounting for current usage including taxes.
   * @return ongoingBalanceCents
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ONGOING_BALANCE_CENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Integer getOngoingBalanceCents() {
    return ongoingBalanceCents;
  }


  @JsonProperty(JSON_PROPERTY_ONGOING_BALANCE_CENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setOngoingBalanceCents(@javax.annotation.Nonnull Integer ongoingBalanceCents) {
    this.ongoingBalanceCents = ongoingBalanceCents;
  }


  public WalletObject ongoingUsageBalanceCents(@javax.annotation.Nonnull Integer ongoingUsageBalanceCents) {
    
    this.ongoingUsageBalanceCents = ongoingUsageBalanceCents;
    return this;
  }

  /**
   * The ongoing usage balance of the wallet, expressed in cents. This reflects all current usage and draft invoices including taxes.
   * @return ongoingUsageBalanceCents
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ONGOING_USAGE_BALANCE_CENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Integer getOngoingUsageBalanceCents() {
    return ongoingUsageBalanceCents;
  }


  @JsonProperty(JSON_PROPERTY_ONGOING_USAGE_BALANCE_CENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setOngoingUsageBalanceCents(@javax.annotation.Nonnull Integer ongoingUsageBalanceCents) {
    this.ongoingUsageBalanceCents = ongoingUsageBalanceCents;
  }


  public WalletObject creditsOngoingBalance(@javax.annotation.Nonnull String creditsOngoingBalance) {
    
    this.creditsOngoingBalance = creditsOngoingBalance;
    return this;
  }

  /**
   * The ongoing wallet balance expressed in credits. This represents the &#x60;credits_balance&#x60; minus the &#x60;credits_ongoing_usage_balance&#x60;, showing the real time balance after accounting for current usage including taxes.
   * @return creditsOngoingBalance
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREDITS_ONGOING_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getCreditsOngoingBalance() {
    return creditsOngoingBalance;
  }


  @JsonProperty(JSON_PROPERTY_CREDITS_ONGOING_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreditsOngoingBalance(@javax.annotation.Nonnull String creditsOngoingBalance) {
    this.creditsOngoingBalance = creditsOngoingBalance;
  }


  public WalletObject creditsOngoingUsageBalance(@javax.annotation.Nonnull String creditsOngoingUsageBalance) {
    
    this.creditsOngoingUsageBalance = creditsOngoingUsageBalance;
    return this;
  }

  /**
   * The ongoing usage balance of the wallet, expressed in credits. This reflects all current usage and draft invoices including taxes.
   * @return creditsOngoingUsageBalance
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREDITS_ONGOING_USAGE_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getCreditsOngoingUsageBalance() {
    return creditsOngoingUsageBalance;
  }


  @JsonProperty(JSON_PROPERTY_CREDITS_ONGOING_USAGE_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreditsOngoingUsageBalance(@javax.annotation.Nonnull String creditsOngoingUsageBalance) {
    this.creditsOngoingUsageBalance = creditsOngoingUsageBalance;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WalletObject walletObject = (WalletObject) o;
    return Objects.equals(this.lagoId, walletObject.lagoId) &&
        Objects.equals(this.lagoCustomerId, walletObject.lagoCustomerId) &&
        Objects.equals(this.externalCustomerId, walletObject.externalCustomerId) &&
        Objects.equals(this.status, walletObject.status) &&
        Objects.equals(this.currency, walletObject.currency) &&
        Objects.equals(this.name, walletObject.name) &&
        Objects.equals(this.rateAmount, walletObject.rateAmount) &&
        Objects.equals(this.creditsBalance, walletObject.creditsBalance) &&
        Objects.equals(this.balanceCents, walletObject.balanceCents) &&
        Objects.equals(this.consumedCredits, walletObject.consumedCredits) &&
        Objects.equals(this.createdAt, walletObject.createdAt) &&
        equalsNullable(this.expirationAt, walletObject.expirationAt) &&
        equalsNullable(this.lastBalanceSyncAt, walletObject.lastBalanceSyncAt) &&
        equalsNullable(this.lastConsumedCreditAt, walletObject.lastConsumedCreditAt) &&
        equalsNullable(this.terminatedAt, walletObject.terminatedAt) &&
        Objects.equals(this.invoiceRequiresSuccessfulPayment, walletObject.invoiceRequiresSuccessfulPayment) &&
        Objects.equals(this.recurringTransactionRules, walletObject.recurringTransactionRules) &&
        Objects.equals(this.ongoingBalanceCents, walletObject.ongoingBalanceCents) &&
        Objects.equals(this.ongoingUsageBalanceCents, walletObject.ongoingUsageBalanceCents) &&
        Objects.equals(this.creditsOngoingBalance, walletObject.creditsOngoingBalance) &&
        Objects.equals(this.creditsOngoingUsageBalance, walletObject.creditsOngoingUsageBalance);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(lagoId, lagoCustomerId, externalCustomerId, status, currency, name, rateAmount, creditsBalance, balanceCents, consumedCredits, createdAt, hashCodeNullable(expirationAt), hashCodeNullable(lastBalanceSyncAt), hashCodeNullable(lastConsumedCreditAt), hashCodeNullable(terminatedAt), invoiceRequiresSuccessfulPayment, recurringTransactionRules, ongoingBalanceCents, ongoingUsageBalanceCents, creditsOngoingBalance, creditsOngoingUsageBalance);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WalletObject {\n");
    sb.append("    lagoId: ").append(toIndentedString(lagoId)).append("\n");
    sb.append("    lagoCustomerId: ").append(toIndentedString(lagoCustomerId)).append("\n");
    sb.append("    externalCustomerId: ").append(toIndentedString(externalCustomerId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    rateAmount: ").append(toIndentedString(rateAmount)).append("\n");
    sb.append("    creditsBalance: ").append(toIndentedString(creditsBalance)).append("\n");
    sb.append("    balanceCents: ").append(toIndentedString(balanceCents)).append("\n");
    sb.append("    consumedCredits: ").append(toIndentedString(consumedCredits)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    expirationAt: ").append(toIndentedString(expirationAt)).append("\n");
    sb.append("    lastBalanceSyncAt: ").append(toIndentedString(lastBalanceSyncAt)).append("\n");
    sb.append("    lastConsumedCreditAt: ").append(toIndentedString(lastConsumedCreditAt)).append("\n");
    sb.append("    terminatedAt: ").append(toIndentedString(terminatedAt)).append("\n");
    sb.append("    invoiceRequiresSuccessfulPayment: ").append(toIndentedString(invoiceRequiresSuccessfulPayment)).append("\n");
    sb.append("    recurringTransactionRules: ").append(toIndentedString(recurringTransactionRules)).append("\n");
    sb.append("    ongoingBalanceCents: ").append(toIndentedString(ongoingBalanceCents)).append("\n");
    sb.append("    ongoingUsageBalanceCents: ").append(toIndentedString(ongoingUsageBalanceCents)).append("\n");
    sb.append("    creditsOngoingBalance: ").append(toIndentedString(creditsOngoingBalance)).append("\n");
    sb.append("    creditsOngoingUsageBalance: ").append(toIndentedString(creditsOngoingUsageBalance)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

