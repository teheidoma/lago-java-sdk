/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.28.1
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BillableMetricFilterInput;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * BillableMetricBaseInput
 */
@JsonPropertyOrder({
  BillableMetricBaseInput.JSON_PROPERTY_NAME,
  BillableMetricBaseInput.JSON_PROPERTY_CODE,
  BillableMetricBaseInput.JSON_PROPERTY_DESCRIPTION,
  BillableMetricBaseInput.JSON_PROPERTY_RECURRING,
  BillableMetricBaseInput.JSON_PROPERTY_EXPRESSION,
  BillableMetricBaseInput.JSON_PROPERTY_ROUNDING_FUNCTION,
  BillableMetricBaseInput.JSON_PROPERTY_ROUNDING_PRECISION,
  BillableMetricBaseInput.JSON_PROPERTY_FIELD_NAME,
  BillableMetricBaseInput.JSON_PROPERTY_AGGREGATION_TYPE,
  BillableMetricBaseInput.JSON_PROPERTY_WEIGHTED_INTERVAL,
  BillableMetricBaseInput.JSON_PROPERTY_FILTERS
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-23T15:05:45.180675+03:00[Europe/Kiev]", comments = "Generator version: 7.13.0")
public class BillableMetricBaseInput {
  public static final String JSON_PROPERTY_NAME = "name";
  @javax.annotation.Nullable
  private String name;

  public static final String JSON_PROPERTY_CODE = "code";
  @javax.annotation.Nullable
  private String code;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  private JsonNullable<String> description = JsonNullable.<String>undefined();

  public static final String JSON_PROPERTY_RECURRING = "recurring";
  @javax.annotation.Nullable
  private Boolean recurring;

  public static final String JSON_PROPERTY_EXPRESSION = "expression";
  private JsonNullable<String> expression = JsonNullable.<String>undefined();

  /**
   * Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are &#x60;round&#x60;, &#x60;ceil&#x60; and &#x60;floor&#x60;.
   */
  public enum RoundingFunctionEnum {
    CEIL(String.valueOf("ceil")),
    
    FLOOR(String.valueOf("floor")),
    
    ROUND(String.valueOf("round"));

    private String value;

    RoundingFunctionEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RoundingFunctionEnum fromValue(String value) {
      for (RoundingFunctionEnum b : RoundingFunctionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }
  }

  public static final String JSON_PROPERTY_ROUNDING_FUNCTION = "rounding_function";
  private JsonNullable<RoundingFunctionEnum> roundingFunction = JsonNullable.<RoundingFunctionEnum>undefined();

  public static final String JSON_PROPERTY_ROUNDING_PRECISION = "rounding_precision";
  private JsonNullable<Integer> roundingPrecision = JsonNullable.<Integer>undefined();

  public static final String JSON_PROPERTY_FIELD_NAME = "field_name";
  private JsonNullable<String> fieldName = JsonNullable.<String>undefined();

  /**
   * Aggregation method used to compute usage for this billable metric.
   */
  public enum AggregationTypeEnum {
    COUNT_AGG(String.valueOf("count_agg")),
    
    SUM_AGG(String.valueOf("sum_agg")),
    
    MAX_AGG(String.valueOf("max_agg")),
    
    UNIQUE_COUNT_AGG(String.valueOf("unique_count_agg")),
    
    WEIGHTED_SUM_AGG(String.valueOf("weighted_sum_agg")),
    
    LATEST_AGG(String.valueOf("latest_agg"));

    private String value;

    AggregationTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AggregationTypeEnum fromValue(String value) {
      for (AggregationTypeEnum b : AggregationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_AGGREGATION_TYPE = "aggregation_type";
  @javax.annotation.Nullable
  private AggregationTypeEnum aggregationType;

  /**
   * Parameter exclusively utilized in conjunction with the &#x60;weighted_sum&#x60; aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in &#x60;seconds&#x60;.
   */
  public enum WeightedIntervalEnum {
    SECONDS(String.valueOf("seconds"));

    private String value;

    WeightedIntervalEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static WeightedIntervalEnum fromValue(String value) {
      for (WeightedIntervalEnum b : WeightedIntervalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }
  }

  public static final String JSON_PROPERTY_WEIGHTED_INTERVAL = "weighted_interval";
  private JsonNullable<WeightedIntervalEnum> weightedInterval = JsonNullable.<WeightedIntervalEnum>undefined();

  public static final String JSON_PROPERTY_FILTERS = "filters";
  @javax.annotation.Nullable
  private List<BillableMetricFilterInput> filters = new ArrayList<>();

  public BillableMetricBaseInput() {
  }

  public BillableMetricBaseInput name(@javax.annotation.Nullable String name) {
    
    this.name = name;
    return this;
  }

  /**
   * Name of the billable metric.
   * @return name
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public BillableMetricBaseInput code(@javax.annotation.Nullable String code) {
    
    this.code = code;
    return this;
  }

  /**
   * Unique code used to identify the billable metric associated with the API request. This code associates each event with the correct metric.
   * @return code
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getCode() {
    return code;
  }


  @JsonProperty(JSON_PROPERTY_CODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCode(@javax.annotation.Nullable String code) {
    this.code = code;
  }


  public BillableMetricBaseInput description(@javax.annotation.Nullable String description) {
    this.description = JsonNullable.<String>of(description);
    
    return this;
  }

  /**
   * Internal description of the billable metric.
   * @return description
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public String getDescription() {
        return description.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getDescription_JsonNullable() {
    return description;
  }
  
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  public void setDescription_JsonNullable(JsonNullable<String> description) {
    this.description = description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = JsonNullable.<String>of(description);
  }


  public BillableMetricBaseInput recurring(@javax.annotation.Nullable Boolean recurring) {
    
    this.recurring = recurring;
    return this;
  }

  /**
   * Defines if the billable metric is persisted billing period over billing period.  - If set to &#x60;true&#x60;: the accumulated number of units calculated from the previous billing period is persisted to the next billing period. - If set to &#x60;false&#x60;: the accumulated number of units is reset to 0 at the end of the billing period. - If not defined in the request, default value is &#x60;false&#x60;.
   * @return recurring
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RECURRING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getRecurring() {
    return recurring;
  }


  @JsonProperty(JSON_PROPERTY_RECURRING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRecurring(@javax.annotation.Nullable Boolean recurring) {
    this.recurring = recurring;
  }


  public BillableMetricBaseInput expression(@javax.annotation.Nullable String expression) {
    this.expression = JsonNullable.<String>of(expression);
    
    return this;
  }

  /**
   * Expression used to calculate the event units. The expression is evalutated for each event and the result is then used to calculate the total aggregated units. Accepted function are &#x60;ceil&#x60;, &#x60;concat&#x60; and &#x60;round&#x60; as well as &#x60;+&#x60;, &#x60;-&#x60;, &#x60;\\&#x60; and &#x60;*&#x60; operations. Round is accepting an optional second parameter to specify the number of decimal. 
   * @return expression
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public String getExpression() {
        return expression.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_EXPRESSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getExpression_JsonNullable() {
    return expression;
  }
  
  @JsonProperty(JSON_PROPERTY_EXPRESSION)
  public void setExpression_JsonNullable(JsonNullable<String> expression) {
    this.expression = expression;
  }

  public void setExpression(@javax.annotation.Nullable String expression) {
    this.expression = JsonNullable.<String>of(expression);
  }


  public BillableMetricBaseInput roundingFunction(@javax.annotation.Nullable RoundingFunctionEnum roundingFunction) {
    this.roundingFunction = JsonNullable.<RoundingFunctionEnum>of(roundingFunction);
    
    return this;
  }

  /**
   * Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are &#x60;round&#x60;, &#x60;ceil&#x60; and &#x60;floor&#x60;.
   * @return roundingFunction
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public RoundingFunctionEnum getRoundingFunction() {
        return roundingFunction.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_ROUNDING_FUNCTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<RoundingFunctionEnum> getRoundingFunction_JsonNullable() {
    return roundingFunction;
  }
  
  @JsonProperty(JSON_PROPERTY_ROUNDING_FUNCTION)
  public void setRoundingFunction_JsonNullable(JsonNullable<RoundingFunctionEnum> roundingFunction) {
    this.roundingFunction = roundingFunction;
  }

  public void setRoundingFunction(@javax.annotation.Nullable RoundingFunctionEnum roundingFunction) {
    this.roundingFunction = JsonNullable.<RoundingFunctionEnum>of(roundingFunction);
  }


  public BillableMetricBaseInput roundingPrecision(@javax.annotation.Nullable Integer roundingPrecision) {
    this.roundingPrecision = JsonNullable.<Integer>of(roundingPrecision);
    
    return this;
  }

  /**
   * Specifies the number of decimal places to which the &#x60;rounding_function&#x60; will be rounded. It can be a positive or negative value.
   * @return roundingPrecision
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public Integer getRoundingPrecision() {
        return roundingPrecision.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_ROUNDING_PRECISION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Integer> getRoundingPrecision_JsonNullable() {
    return roundingPrecision;
  }
  
  @JsonProperty(JSON_PROPERTY_ROUNDING_PRECISION)
  public void setRoundingPrecision_JsonNullable(JsonNullable<Integer> roundingPrecision) {
    this.roundingPrecision = roundingPrecision;
  }

  public void setRoundingPrecision(@javax.annotation.Nullable Integer roundingPrecision) {
    this.roundingPrecision = JsonNullable.<Integer>of(roundingPrecision);
  }


  public BillableMetricBaseInput fieldName(@javax.annotation.Nullable String fieldName) {
    this.fieldName = JsonNullable.<String>of(fieldName);
    
    return this;
  }

  /**
   * Property of the billable metric used for aggregating usage data. This field is not required for &#x60;count_agg&#x60;.
   * @return fieldName
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public String getFieldName() {
        return fieldName.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_FIELD_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getFieldName_JsonNullable() {
    return fieldName;
  }
  
  @JsonProperty(JSON_PROPERTY_FIELD_NAME)
  public void setFieldName_JsonNullable(JsonNullable<String> fieldName) {
    this.fieldName = fieldName;
  }

  public void setFieldName(@javax.annotation.Nullable String fieldName) {
    this.fieldName = JsonNullable.<String>of(fieldName);
  }


  public BillableMetricBaseInput aggregationType(@javax.annotation.Nullable AggregationTypeEnum aggregationType) {
    
    this.aggregationType = aggregationType;
    return this;
  }

  /**
   * Aggregation method used to compute usage for this billable metric.
   * @return aggregationType
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_AGGREGATION_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public AggregationTypeEnum getAggregationType() {
    return aggregationType;
  }


  @JsonProperty(JSON_PROPERTY_AGGREGATION_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAggregationType(@javax.annotation.Nullable AggregationTypeEnum aggregationType) {
    this.aggregationType = aggregationType;
  }


  public BillableMetricBaseInput weightedInterval(@javax.annotation.Nullable WeightedIntervalEnum weightedInterval) {
    this.weightedInterval = JsonNullable.<WeightedIntervalEnum>of(weightedInterval);
    
    return this;
  }

  /**
   * Parameter exclusively utilized in conjunction with the &#x60;weighted_sum&#x60; aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in &#x60;seconds&#x60;.
   * @return weightedInterval
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public WeightedIntervalEnum getWeightedInterval() {
        return weightedInterval.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_WEIGHTED_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<WeightedIntervalEnum> getWeightedInterval_JsonNullable() {
    return weightedInterval;
  }
  
  @JsonProperty(JSON_PROPERTY_WEIGHTED_INTERVAL)
  public void setWeightedInterval_JsonNullable(JsonNullable<WeightedIntervalEnum> weightedInterval) {
    this.weightedInterval = weightedInterval;
  }

  public void setWeightedInterval(@javax.annotation.Nullable WeightedIntervalEnum weightedInterval) {
    this.weightedInterval = JsonNullable.<WeightedIntervalEnum>of(weightedInterval);
  }


  public BillableMetricBaseInput filters(@javax.annotation.Nullable List<BillableMetricFilterInput> filters) {
    
    this.filters = filters;
    return this;
  }

  public BillableMetricBaseInput addFiltersItem(BillableMetricFilterInput filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

  /**
   * Get filters
   * @return filters
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<BillableMetricFilterInput> getFilters() {
    return filters;
  }


  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFilters(@javax.annotation.Nullable List<BillableMetricFilterInput> filters) {
    this.filters = filters;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BillableMetricBaseInput billableMetricBaseInput = (BillableMetricBaseInput) o;
    return Objects.equals(this.name, billableMetricBaseInput.name) &&
        Objects.equals(this.code, billableMetricBaseInput.code) &&
        equalsNullable(this.description, billableMetricBaseInput.description) &&
        Objects.equals(this.recurring, billableMetricBaseInput.recurring) &&
        equalsNullable(this.expression, billableMetricBaseInput.expression) &&
        equalsNullable(this.roundingFunction, billableMetricBaseInput.roundingFunction) &&
        equalsNullable(this.roundingPrecision, billableMetricBaseInput.roundingPrecision) &&
        equalsNullable(this.fieldName, billableMetricBaseInput.fieldName) &&
        Objects.equals(this.aggregationType, billableMetricBaseInput.aggregationType) &&
        equalsNullable(this.weightedInterval, billableMetricBaseInput.weightedInterval) &&
        Objects.equals(this.filters, billableMetricBaseInput.filters);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, code, hashCodeNullable(description), recurring, hashCodeNullable(expression), hashCodeNullable(roundingFunction), hashCodeNullable(roundingPrecision), hashCodeNullable(fieldName), aggregationType, hashCodeNullable(weightedInterval), filters);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BillableMetricBaseInput {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    recurring: ").append(toIndentedString(recurring)).append("\n");
    sb.append("    expression: ").append(toIndentedString(expression)).append("\n");
    sb.append("    roundingFunction: ").append(toIndentedString(roundingFunction)).append("\n");
    sb.append("    roundingPrecision: ").append(toIndentedString(roundingPrecision)).append("\n");
    sb.append("    fieldName: ").append(toIndentedString(fieldName)).append("\n");
    sb.append("    aggregationType: ").append(toIndentedString(aggregationType)).append("\n");
    sb.append("    weightedInterval: ").append(toIndentedString(weightedInterval)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

