/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.28.1
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.BillableMetricFilterObject;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * BillableMetricObject
 */
@JsonPropertyOrder({
  BillableMetricObject.JSON_PROPERTY_LAGO_ID,
  BillableMetricObject.JSON_PROPERTY_NAME,
  BillableMetricObject.JSON_PROPERTY_CODE,
  BillableMetricObject.JSON_PROPERTY_DESCRIPTION,
  BillableMetricObject.JSON_PROPERTY_RECURRING,
  BillableMetricObject.JSON_PROPERTY_ROUNDING_FUNCTION,
  BillableMetricObject.JSON_PROPERTY_ROUNDING_PRECISION,
  BillableMetricObject.JSON_PROPERTY_CREATED_AT,
  BillableMetricObject.JSON_PROPERTY_EXPRESSION,
  BillableMetricObject.JSON_PROPERTY_FIELD_NAME,
  BillableMetricObject.JSON_PROPERTY_AGGREGATION_TYPE,
  BillableMetricObject.JSON_PROPERTY_WEIGHTED_INTERVAL,
  BillableMetricObject.JSON_PROPERTY_FILTERS
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-23T15:05:45.180675+03:00[Europe/Kiev]", comments = "Generator version: 7.13.0")
public class BillableMetricObject {
  public static final String JSON_PROPERTY_LAGO_ID = "lago_id";
  @javax.annotation.Nonnull
  private UUID lagoId;

  public static final String JSON_PROPERTY_NAME = "name";
  @javax.annotation.Nonnull
  private String name;

  public static final String JSON_PROPERTY_CODE = "code";
  @javax.annotation.Nonnull
  private String code;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  private JsonNullable<String> description = JsonNullable.<String>undefined();

  public static final String JSON_PROPERTY_RECURRING = "recurring";
  @javax.annotation.Nonnull
  private Boolean recurring;

  /**
   * Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are &#x60;round&#x60;, &#x60;ceil&#x60; and &#x60;floor&#x60;.
   */
  public enum RoundingFunctionEnum {
    CEIL(String.valueOf("ceil")),
    
    FLOOR(String.valueOf("floor")),
    
    ROUND(String.valueOf("round"));

    private String value;

    RoundingFunctionEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RoundingFunctionEnum fromValue(String value) {
      for (RoundingFunctionEnum b : RoundingFunctionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }
  }

  public static final String JSON_PROPERTY_ROUNDING_FUNCTION = "rounding_function";
  private JsonNullable<RoundingFunctionEnum> roundingFunction = JsonNullable.<RoundingFunctionEnum>undefined();

  public static final String JSON_PROPERTY_ROUNDING_PRECISION = "rounding_precision";
  private JsonNullable<Integer> roundingPrecision = JsonNullable.<Integer>undefined();

  public static final String JSON_PROPERTY_CREATED_AT = "created_at";
  @javax.annotation.Nonnull
  private OffsetDateTime createdAt;

  public static final String JSON_PROPERTY_EXPRESSION = "expression";
  @javax.annotation.Nullable
  private String expression;

  public static final String JSON_PROPERTY_FIELD_NAME = "field_name";
  private JsonNullable<String> fieldName = JsonNullable.<String>undefined();

  /**
   * Aggregation method used to compute usage for this billable metric.
   */
  public enum AggregationTypeEnum {
    COUNT_AGG(String.valueOf("count_agg")),
    
    SUM_AGG(String.valueOf("sum_agg")),
    
    MAX_AGG(String.valueOf("max_agg")),
    
    UNIQUE_COUNT_AGG(String.valueOf("unique_count_agg")),
    
    WEIGHTED_SUM_AGG(String.valueOf("weighted_sum_agg")),
    
    LATEST_AGG(String.valueOf("latest_agg"));

    private String value;

    AggregationTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AggregationTypeEnum fromValue(String value) {
      for (AggregationTypeEnum b : AggregationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_AGGREGATION_TYPE = "aggregation_type";
  @javax.annotation.Nonnull
  private AggregationTypeEnum aggregationType;

  /**
   * Parameter exclusively utilized in conjunction with the &#x60;weighted_sum&#x60; aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in &#x60;seconds&#x60;.
   */
  public enum WeightedIntervalEnum {
    SECONDS(String.valueOf("seconds"));

    private String value;

    WeightedIntervalEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static WeightedIntervalEnum fromValue(String value) {
      for (WeightedIntervalEnum b : WeightedIntervalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }
  }

  public static final String JSON_PROPERTY_WEIGHTED_INTERVAL = "weighted_interval";
  private JsonNullable<WeightedIntervalEnum> weightedInterval = JsonNullable.<WeightedIntervalEnum>undefined();

  public static final String JSON_PROPERTY_FILTERS = "filters";
  @javax.annotation.Nullable
  private List<BillableMetricFilterObject> filters = new ArrayList<>();

  public BillableMetricObject() {
  }

  public BillableMetricObject lagoId(@javax.annotation.Nonnull UUID lagoId) {
    
    this.lagoId = lagoId;
    return this;
  }

  /**
   * Unique identifier of the billable metric created by Lago.
   * @return lagoId
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getLagoId() {
    return lagoId;
  }


  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLagoId(@javax.annotation.Nonnull UUID lagoId) {
    this.lagoId = lagoId;
  }


  public BillableMetricObject name(@javax.annotation.Nonnull String name) {
    
    this.name = name;
    return this;
  }

  /**
   * Name of the billable metric.
   * @return name
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public BillableMetricObject code(@javax.annotation.Nonnull String code) {
    
    this.code = code;
    return this;
  }

  /**
   * Unique code used to identify the billable metric associated with the API request. This code associates each event with the correct metric.
   * @return code
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CODE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getCode() {
    return code;
  }


  @JsonProperty(JSON_PROPERTY_CODE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCode(@javax.annotation.Nonnull String code) {
    this.code = code;
  }


  public BillableMetricObject description(@javax.annotation.Nullable String description) {
    this.description = JsonNullable.<String>of(description);
    
    return this;
  }

  /**
   * Internal description of the billable metric.
   * @return description
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public String getDescription() {
        return description.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getDescription_JsonNullable() {
    return description;
  }
  
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  public void setDescription_JsonNullable(JsonNullable<String> description) {
    this.description = description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = JsonNullable.<String>of(description);
  }


  public BillableMetricObject recurring(@javax.annotation.Nonnull Boolean recurring) {
    
    this.recurring = recurring;
    return this;
  }

  /**
   * Defines if the billable metric is persisted billing period over billing period.  - If set to &#x60;true&#x60;: the accumulated number of units calculated from the previous billing period is persisted to the next billing period. - If set to &#x60;false&#x60;: the accumulated number of units is reset to 0 at the end of the billing period. - If not defined in the request, default value is &#x60;false&#x60;.
   * @return recurring
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RECURRING)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getRecurring() {
    return recurring;
  }


  @JsonProperty(JSON_PROPERTY_RECURRING)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRecurring(@javax.annotation.Nonnull Boolean recurring) {
    this.recurring = recurring;
  }


  public BillableMetricObject roundingFunction(@javax.annotation.Nullable RoundingFunctionEnum roundingFunction) {
    this.roundingFunction = JsonNullable.<RoundingFunctionEnum>of(roundingFunction);
    
    return this;
  }

  /**
   * Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are &#x60;round&#x60;, &#x60;ceil&#x60; and &#x60;floor&#x60;.
   * @return roundingFunction
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public RoundingFunctionEnum getRoundingFunction() {
        return roundingFunction.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_ROUNDING_FUNCTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<RoundingFunctionEnum> getRoundingFunction_JsonNullable() {
    return roundingFunction;
  }
  
  @JsonProperty(JSON_PROPERTY_ROUNDING_FUNCTION)
  public void setRoundingFunction_JsonNullable(JsonNullable<RoundingFunctionEnum> roundingFunction) {
    this.roundingFunction = roundingFunction;
  }

  public void setRoundingFunction(@javax.annotation.Nullable RoundingFunctionEnum roundingFunction) {
    this.roundingFunction = JsonNullable.<RoundingFunctionEnum>of(roundingFunction);
  }


  public BillableMetricObject roundingPrecision(@javax.annotation.Nullable Integer roundingPrecision) {
    this.roundingPrecision = JsonNullable.<Integer>of(roundingPrecision);
    
    return this;
  }

  /**
   * Specifies the number of decimal places to which the &#x60;rounding_function&#x60; will be rounded. It can be a positive or negative value.
   * @return roundingPrecision
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public Integer getRoundingPrecision() {
        return roundingPrecision.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_ROUNDING_PRECISION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Integer> getRoundingPrecision_JsonNullable() {
    return roundingPrecision;
  }
  
  @JsonProperty(JSON_PROPERTY_ROUNDING_PRECISION)
  public void setRoundingPrecision_JsonNullable(JsonNullable<Integer> roundingPrecision) {
    this.roundingPrecision = roundingPrecision;
  }

  public void setRoundingPrecision(@javax.annotation.Nullable Integer roundingPrecision) {
    this.roundingPrecision = JsonNullable.<Integer>of(roundingPrecision);
  }


  public BillableMetricObject createdAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    
    this.createdAt = createdAt;
    return this;
  }

  /**
   * Creation date of the billable metric.
   * @return createdAt
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }


  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreatedAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public BillableMetricObject expression(@javax.annotation.Nullable String expression) {
    
    this.expression = expression;
    return this;
  }

  /**
   * Expression used to calculate the event units. The expression is evalutated for each event and the result is then used to calculate the total aggregated units.
   * @return expression
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_EXPRESSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getExpression() {
    return expression;
  }


  @JsonProperty(JSON_PROPERTY_EXPRESSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setExpression(@javax.annotation.Nullable String expression) {
    this.expression = expression;
  }


  public BillableMetricObject fieldName(@javax.annotation.Nullable String fieldName) {
    this.fieldName = JsonNullable.<String>of(fieldName);
    
    return this;
  }

  /**
   * Property of the billable metric used for aggregating usage data. This field is not required for &#x60;count_agg&#x60;.
   * @return fieldName
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public String getFieldName() {
        return fieldName.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_FIELD_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getFieldName_JsonNullable() {
    return fieldName;
  }
  
  @JsonProperty(JSON_PROPERTY_FIELD_NAME)
  public void setFieldName_JsonNullable(JsonNullable<String> fieldName) {
    this.fieldName = fieldName;
  }

  public void setFieldName(@javax.annotation.Nullable String fieldName) {
    this.fieldName = JsonNullable.<String>of(fieldName);
  }


  public BillableMetricObject aggregationType(@javax.annotation.Nonnull AggregationTypeEnum aggregationType) {
    
    this.aggregationType = aggregationType;
    return this;
  }

  /**
   * Aggregation method used to compute usage for this billable metric.
   * @return aggregationType
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_AGGREGATION_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public AggregationTypeEnum getAggregationType() {
    return aggregationType;
  }


  @JsonProperty(JSON_PROPERTY_AGGREGATION_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAggregationType(@javax.annotation.Nonnull AggregationTypeEnum aggregationType) {
    this.aggregationType = aggregationType;
  }


  public BillableMetricObject weightedInterval(@javax.annotation.Nullable WeightedIntervalEnum weightedInterval) {
    this.weightedInterval = JsonNullable.<WeightedIntervalEnum>of(weightedInterval);
    
    return this;
  }

  /**
   * Parameter exclusively utilized in conjunction with the &#x60;weighted_sum&#x60; aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in &#x60;seconds&#x60;.
   * @return weightedInterval
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public WeightedIntervalEnum getWeightedInterval() {
        return weightedInterval.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_WEIGHTED_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<WeightedIntervalEnum> getWeightedInterval_JsonNullable() {
    return weightedInterval;
  }
  
  @JsonProperty(JSON_PROPERTY_WEIGHTED_INTERVAL)
  public void setWeightedInterval_JsonNullable(JsonNullable<WeightedIntervalEnum> weightedInterval) {
    this.weightedInterval = weightedInterval;
  }

  public void setWeightedInterval(@javax.annotation.Nullable WeightedIntervalEnum weightedInterval) {
    this.weightedInterval = JsonNullable.<WeightedIntervalEnum>of(weightedInterval);
  }


  public BillableMetricObject filters(@javax.annotation.Nullable List<BillableMetricFilterObject> filters) {
    
    this.filters = filters;
    return this;
  }

  public BillableMetricObject addFiltersItem(BillableMetricFilterObject filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

  /**
   * Get filters
   * @return filters
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<BillableMetricFilterObject> getFilters() {
    return filters;
  }


  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFilters(@javax.annotation.Nullable List<BillableMetricFilterObject> filters) {
    this.filters = filters;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BillableMetricObject billableMetricObject = (BillableMetricObject) o;
    return Objects.equals(this.lagoId, billableMetricObject.lagoId) &&
        Objects.equals(this.name, billableMetricObject.name) &&
        Objects.equals(this.code, billableMetricObject.code) &&
        equalsNullable(this.description, billableMetricObject.description) &&
        Objects.equals(this.recurring, billableMetricObject.recurring) &&
        equalsNullable(this.roundingFunction, billableMetricObject.roundingFunction) &&
        equalsNullable(this.roundingPrecision, billableMetricObject.roundingPrecision) &&
        Objects.equals(this.createdAt, billableMetricObject.createdAt) &&
        Objects.equals(this.expression, billableMetricObject.expression) &&
        equalsNullable(this.fieldName, billableMetricObject.fieldName) &&
        Objects.equals(this.aggregationType, billableMetricObject.aggregationType) &&
        equalsNullable(this.weightedInterval, billableMetricObject.weightedInterval) &&
        Objects.equals(this.filters, billableMetricObject.filters);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(lagoId, name, code, hashCodeNullable(description), recurring, hashCodeNullable(roundingFunction), hashCodeNullable(roundingPrecision), createdAt, expression, hashCodeNullable(fieldName), aggregationType, hashCodeNullable(weightedInterval), filters);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BillableMetricObject {\n");
    sb.append("    lagoId: ").append(toIndentedString(lagoId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    recurring: ").append(toIndentedString(recurring)).append("\n");
    sb.append("    roundingFunction: ").append(toIndentedString(roundingFunction)).append("\n");
    sb.append("    roundingPrecision: ").append(toIndentedString(roundingPrecision)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    expression: ").append(toIndentedString(expression)).append("\n");
    sb.append("    fieldName: ").append(toIndentedString(fieldName)).append("\n");
    sb.append("    aggregationType: ").append(toIndentedString(aggregationType)).append("\n");
    sb.append("    weightedInterval: ").append(toIndentedString(weightedInterval)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

