/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.28.1
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.WalletRecurringTransactionRuleTransactionMetadataInner;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Object that represents rule for wallet recurring transactions.
 */
@JsonPropertyOrder({
  WalletRecurringTransactionRule.JSON_PROPERTY_LAGO_ID,
  WalletRecurringTransactionRule.JSON_PROPERTY_TRIGGER,
  WalletRecurringTransactionRule.JSON_PROPERTY_METHOD,
  WalletRecurringTransactionRule.JSON_PROPERTY_INTERVAL,
  WalletRecurringTransactionRule.JSON_PROPERTY_STATUS,
  WalletRecurringTransactionRule.JSON_PROPERTY_THRESHOLD_CREDITS,
  WalletRecurringTransactionRule.JSON_PROPERTY_PAID_CREDITS,
  WalletRecurringTransactionRule.JSON_PROPERTY_GRANTED_CREDITS,
  WalletRecurringTransactionRule.JSON_PROPERTY_STARTED_AT,
  WalletRecurringTransactionRule.JSON_PROPERTY_TARGET_ONGOING_BALANCE,
  WalletRecurringTransactionRule.JSON_PROPERTY_CREATED_AT,
  WalletRecurringTransactionRule.JSON_PROPERTY_EXPIRATION_AT,
  WalletRecurringTransactionRule.JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT,
  WalletRecurringTransactionRule.JSON_PROPERTY_TRANSACTION_METADATA
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-23T15:05:45.180675+03:00[Europe/Kiev]", comments = "Generator version: 7.13.0")
public class WalletRecurringTransactionRule {
  public static final String JSON_PROPERTY_LAGO_ID = "lago_id";
  @javax.annotation.Nonnull
  private UUID lagoId;

  /**
   * The trigger. Possible values are &#x60;interval&#x60; or &#x60;threshold&#x60;.
   */
  public enum TriggerEnum {
    INTERVAL(String.valueOf("interval")),
    
    THRESHOLD(String.valueOf("threshold"));

    private String value;

    TriggerEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TriggerEnum fromValue(String value) {
      for (TriggerEnum b : TriggerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_TRIGGER = "trigger";
  @javax.annotation.Nonnull
  private TriggerEnum trigger;

  /**
   * The method used for recurring top-up. Possible values are &#x60;fixed&#x60; or &#x60;target&#x60;.
   */
  public enum MethodEnum {
    FIXED(String.valueOf("fixed")),
    
    TARGET(String.valueOf("target"));

    private String value;

    MethodEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static MethodEnum fromValue(String value) {
      for (MethodEnum b : MethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_METHOD = "method";
  @javax.annotation.Nonnull
  private MethodEnum method;

  /**
   * The interval used for recurring top-up. It represents the frequency at which automatic top-up occurs. The interval can be one of the following values: &#x60;weekly&#x60;, &#x60;monthly&#x60;, &#x60;quarterly&#x60; or &#x60;yearly&#x60;. Required only if trigger is set to &#x60;interval&#x60;.
   */
  public enum IntervalEnum {
    WEEKLY(String.valueOf("weekly")),
    
    MONTHLY(String.valueOf("monthly")),
    
    QUARTERLY(String.valueOf("quarterly")),
    
    YEARLY(String.valueOf("yearly"));

    private String value;

    IntervalEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static IntervalEnum fromValue(String value) {
      for (IntervalEnum b : IntervalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_INTERVAL = "interval";
  @javax.annotation.Nonnull
  private IntervalEnum interval;

  /**
   * The status of the recurring transaction rule. Possible values are &#x60;active&#x60; or &#x60;terminated&#x60;.
   */
  public enum StatusEnum {
    ACTIVE(String.valueOf("active")),
    
    TERMINATED(String.valueOf("terminated"));

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_STATUS = "status";
  @javax.annotation.Nullable
  private StatusEnum status;

  public static final String JSON_PROPERTY_THRESHOLD_CREDITS = "threshold_credits";
  @javax.annotation.Nonnull
  private String thresholdCredits;

  public static final String JSON_PROPERTY_PAID_CREDITS = "paid_credits";
  @javax.annotation.Nonnull
  private String paidCredits;

  public static final String JSON_PROPERTY_GRANTED_CREDITS = "granted_credits";
  @javax.annotation.Nonnull
  private String grantedCredits;

  public static final String JSON_PROPERTY_STARTED_AT = "started_at";
  @javax.annotation.Nullable
  private OffsetDateTime startedAt;

  public static final String JSON_PROPERTY_TARGET_ONGOING_BALANCE = "target_ongoing_balance";
  @javax.annotation.Nonnull
  private String targetOngoingBalance;

  public static final String JSON_PROPERTY_CREATED_AT = "created_at";
  @javax.annotation.Nonnull
  private OffsetDateTime createdAt;

  public static final String JSON_PROPERTY_EXPIRATION_AT = "expiration_at";
  @javax.annotation.Nullable
  private OffsetDateTime expirationAt;

  public static final String JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT = "invoice_requires_successful_payment";
  @javax.annotation.Nullable
  private Boolean invoiceRequiresSuccessfulPayment;

  public static final String JSON_PROPERTY_TRANSACTION_METADATA = "transaction_metadata";
  @javax.annotation.Nullable
  private List<WalletRecurringTransactionRuleTransactionMetadataInner> transactionMetadata = new ArrayList<>();

  public WalletRecurringTransactionRule() {
  }

  public WalletRecurringTransactionRule lagoId(@javax.annotation.Nonnull UUID lagoId) {
    
    this.lagoId = lagoId;
    return this;
  }

  /**
   * A unique identifier for the recurring transaction rule in the Lago application. Can be used to update a recurring transaction rule.
   * @return lagoId
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getLagoId() {
    return lagoId;
  }


  @JsonProperty(JSON_PROPERTY_LAGO_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLagoId(@javax.annotation.Nonnull UUID lagoId) {
    this.lagoId = lagoId;
  }


  public WalletRecurringTransactionRule trigger(@javax.annotation.Nonnull TriggerEnum trigger) {
    
    this.trigger = trigger;
    return this;
  }

  /**
   * The trigger. Possible values are &#x60;interval&#x60; or &#x60;threshold&#x60;.
   * @return trigger
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TRIGGER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public TriggerEnum getTrigger() {
    return trigger;
  }


  @JsonProperty(JSON_PROPERTY_TRIGGER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTrigger(@javax.annotation.Nonnull TriggerEnum trigger) {
    this.trigger = trigger;
  }


  public WalletRecurringTransactionRule method(@javax.annotation.Nonnull MethodEnum method) {
    
    this.method = method;
    return this;
  }

  /**
   * The method used for recurring top-up. Possible values are &#x60;fixed&#x60; or &#x60;target&#x60;.
   * @return method
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public MethodEnum getMethod() {
    return method;
  }


  @JsonProperty(JSON_PROPERTY_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMethod(@javax.annotation.Nonnull MethodEnum method) {
    this.method = method;
  }


  public WalletRecurringTransactionRule interval(@javax.annotation.Nonnull IntervalEnum interval) {
    
    this.interval = interval;
    return this;
  }

  /**
   * The interval used for recurring top-up. It represents the frequency at which automatic top-up occurs. The interval can be one of the following values: &#x60;weekly&#x60;, &#x60;monthly&#x60;, &#x60;quarterly&#x60; or &#x60;yearly&#x60;. Required only if trigger is set to &#x60;interval&#x60;.
   * @return interval
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public IntervalEnum getInterval() {
    return interval;
  }


  @JsonProperty(JSON_PROPERTY_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setInterval(@javax.annotation.Nonnull IntervalEnum interval) {
    this.interval = interval;
  }


  public WalletRecurringTransactionRule status(@javax.annotation.Nullable StatusEnum status) {
    
    this.status = status;
    return this;
  }

  /**
   * The status of the recurring transaction rule. Possible values are &#x60;active&#x60; or &#x60;terminated&#x60;.
   * @return status
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STATUS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StatusEnum getStatus() {
    return status;
  }


  @JsonProperty(JSON_PROPERTY_STATUS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStatus(@javax.annotation.Nullable StatusEnum status) {
    this.status = status;
  }


  public WalletRecurringTransactionRule thresholdCredits(@javax.annotation.Nonnull String thresholdCredits) {
    
    this.thresholdCredits = thresholdCredits;
    return this;
  }

  /**
   * The threshold for recurring top-ups is the value at which an automatic top-up is triggered. For example, if this threshold is set at 10 credits, an automatic top-up will occur whenever the wallet balance falls to or below 10 credits. Required only when trigger is set to &#x60;threshold&#x60;.
   * @return thresholdCredits
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_THRESHOLD_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getThresholdCredits() {
    return thresholdCredits;
  }


  @JsonProperty(JSON_PROPERTY_THRESHOLD_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setThresholdCredits(@javax.annotation.Nonnull String thresholdCredits) {
    this.thresholdCredits = thresholdCredits;
  }


  public WalletRecurringTransactionRule paidCredits(@javax.annotation.Nonnull String paidCredits) {
    
    this.paidCredits = paidCredits;
    return this;
  }

  /**
   * The number of paid credits. Required only if there is no granted credits.
   * @return paidCredits
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_PAID_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getPaidCredits() {
    return paidCredits;
  }


  @JsonProperty(JSON_PROPERTY_PAID_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPaidCredits(@javax.annotation.Nonnull String paidCredits) {
    this.paidCredits = paidCredits;
  }


  public WalletRecurringTransactionRule grantedCredits(@javax.annotation.Nonnull String grantedCredits) {
    
    this.grantedCredits = grantedCredits;
    return this;
  }

  /**
   * The number of free granted credits. Required only if there is no paid credits.
   * @return grantedCredits
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_GRANTED_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getGrantedCredits() {
    return grantedCredits;
  }


  @JsonProperty(JSON_PROPERTY_GRANTED_CREDITS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setGrantedCredits(@javax.annotation.Nonnull String grantedCredits) {
    this.grantedCredits = grantedCredits;
  }


  public WalletRecurringTransactionRule startedAt(@javax.annotation.Nullable OffsetDateTime startedAt) {
    
    this.startedAt = startedAt;
    return this;
  }

  /**
   * The effective start date for recurring top-ups. This date should be provided in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).
   * @return startedAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STARTED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getStartedAt() {
    return startedAt;
  }


  @JsonProperty(JSON_PROPERTY_STARTED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartedAt(@javax.annotation.Nullable OffsetDateTime startedAt) {
    this.startedAt = startedAt;
  }


  public WalletRecurringTransactionRule targetOngoingBalance(@javax.annotation.Nonnull String targetOngoingBalance) {
    
    this.targetOngoingBalance = targetOngoingBalance;
    return this;
  }

  /**
   * The target ongoing balance is the value set for the ongoing balance to be reached by the automatic top-up. Required only when trigger is set to &#x60;target&#x60;.
   * @return targetOngoingBalance
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TARGET_ONGOING_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getTargetOngoingBalance() {
    return targetOngoingBalance;
  }


  @JsonProperty(JSON_PROPERTY_TARGET_ONGOING_BALANCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTargetOngoingBalance(@javax.annotation.Nonnull String targetOngoingBalance) {
    this.targetOngoingBalance = targetOngoingBalance;
  }


  public WalletRecurringTransactionRule createdAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    
    this.createdAt = createdAt;
    return this;
  }

  /**
   * The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created
   * @return createdAt
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }


  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreatedAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public WalletRecurringTransactionRule expirationAt(@javax.annotation.Nullable OffsetDateTime expirationAt) {
    
    this.expirationAt = expirationAt;
    return this;
  }

  /**
   * The expiration date and time for this specific recurring transaction rule. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return expirationAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_EXPIRATION_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getExpirationAt() {
    return expirationAt;
  }


  @JsonProperty(JSON_PROPERTY_EXPIRATION_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setExpirationAt(@javax.annotation.Nullable OffsetDateTime expirationAt) {
    this.expirationAt = expirationAt;
  }


  public WalletRecurringTransactionRule invoiceRequiresSuccessfulPayment(@javax.annotation.Nullable Boolean invoiceRequiresSuccessfulPayment) {
    
    this.invoiceRequiresSuccessfulPayment = invoiceRequiresSuccessfulPayment;
    return this;
  }

  /**
   * A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.
   * @return invoiceRequiresSuccessfulPayment
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getInvoiceRequiresSuccessfulPayment() {
    return invoiceRequiresSuccessfulPayment;
  }


  @JsonProperty(JSON_PROPERTY_INVOICE_REQUIRES_SUCCESSFUL_PAYMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInvoiceRequiresSuccessfulPayment(@javax.annotation.Nullable Boolean invoiceRequiresSuccessfulPayment) {
    this.invoiceRequiresSuccessfulPayment = invoiceRequiresSuccessfulPayment;
  }


  public WalletRecurringTransactionRule transactionMetadata(@javax.annotation.Nullable List<WalletRecurringTransactionRuleTransactionMetadataInner> transactionMetadata) {
    
    this.transactionMetadata = transactionMetadata;
    return this;
  }

  public WalletRecurringTransactionRule addTransactionMetadataItem(WalletRecurringTransactionRuleTransactionMetadataInner transactionMetadataItem) {
    if (this.transactionMetadata == null) {
      this.transactionMetadata = new ArrayList<>();
    }
    this.transactionMetadata.add(transactionMetadataItem);
    return this;
  }

  /**
   * This field allows you to store a list of key-value pairs containing additional information or custom attributes. These key-value pairs will populate the metadata of the wallet transactions triggered by this rule.
   * @return transactionMetadata
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TRANSACTION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<WalletRecurringTransactionRuleTransactionMetadataInner> getTransactionMetadata() {
    return transactionMetadata;
  }


  @JsonProperty(JSON_PROPERTY_TRANSACTION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTransactionMetadata(@javax.annotation.Nullable List<WalletRecurringTransactionRuleTransactionMetadataInner> transactionMetadata) {
    this.transactionMetadata = transactionMetadata;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WalletRecurringTransactionRule walletRecurringTransactionRule = (WalletRecurringTransactionRule) o;
    return Objects.equals(this.lagoId, walletRecurringTransactionRule.lagoId) &&
        Objects.equals(this.trigger, walletRecurringTransactionRule.trigger) &&
        Objects.equals(this.method, walletRecurringTransactionRule.method) &&
        Objects.equals(this.interval, walletRecurringTransactionRule.interval) &&
        Objects.equals(this.status, walletRecurringTransactionRule.status) &&
        Objects.equals(this.thresholdCredits, walletRecurringTransactionRule.thresholdCredits) &&
        Objects.equals(this.paidCredits, walletRecurringTransactionRule.paidCredits) &&
        Objects.equals(this.grantedCredits, walletRecurringTransactionRule.grantedCredits) &&
        Objects.equals(this.startedAt, walletRecurringTransactionRule.startedAt) &&
        Objects.equals(this.targetOngoingBalance, walletRecurringTransactionRule.targetOngoingBalance) &&
        Objects.equals(this.createdAt, walletRecurringTransactionRule.createdAt) &&
        Objects.equals(this.expirationAt, walletRecurringTransactionRule.expirationAt) &&
        Objects.equals(this.invoiceRequiresSuccessfulPayment, walletRecurringTransactionRule.invoiceRequiresSuccessfulPayment) &&
        Objects.equals(this.transactionMetadata, walletRecurringTransactionRule.transactionMetadata);
  }

  @Override
  public int hashCode() {
    return Objects.hash(lagoId, trigger, method, interval, status, thresholdCredits, paidCredits, grantedCredits, startedAt, targetOngoingBalance, createdAt, expirationAt, invoiceRequiresSuccessfulPayment, transactionMetadata);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WalletRecurringTransactionRule {\n");
    sb.append("    lagoId: ").append(toIndentedString(lagoId)).append("\n");
    sb.append("    trigger: ").append(toIndentedString(trigger)).append("\n");
    sb.append("    method: ").append(toIndentedString(method)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    thresholdCredits: ").append(toIndentedString(thresholdCredits)).append("\n");
    sb.append("    paidCredits: ").append(toIndentedString(paidCredits)).append("\n");
    sb.append("    grantedCredits: ").append(toIndentedString(grantedCredits)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("    targetOngoingBalance: ").append(toIndentedString(targetOngoingBalance)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    expirationAt: ").append(toIndentedString(expirationAt)).append("\n");
    sb.append("    invoiceRequiresSuccessfulPayment: ").append(toIndentedString(invoiceRequiresSuccessfulPayment)).append("\n");
    sb.append("    transactionMetadata: ").append(toIndentedString(transactionMetadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

